\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{array}
\usepackage{caption}
\usepackage{fancyhdr}

\geometry{margin=2.5cm}

% Configuração de código
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegray},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\begin{document}

% Capa
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\LARGE\bfseries Universidade Federal [Sua Universidade]\par}
    \vspace{0.5cm}
    {\large Curso de [Seu Curso]\par}
    \vspace{0.5cm}
    {\large Disciplina: Qualidade de Software\par}
    
    \vspace{3cm}
    
    {\huge\bfseries Análise de Eficácia de Testes com Teste de Mutação\par}
    
    \vspace{1cm}
    
    {\Large Trabalho Prático - StrykerJS\par}
    
    \vspace{3cm}
    
    {\large
    \textbf{Nome:} [Seu Nome Completo]\\
    \textbf{Matrícula:} [Sua Matrícula]\\
    }
    
    \vfill
    
    {\large 02 de novembro de 2025\par}
\end{titlepage}

\newpage

% Sumário
\tableofcontents
\newpage

\section{Introdução}

Este trabalho tem como objetivo demonstrar na prática a diferença fundamental entre \textbf{cobertura de código} e \textbf{eficácia de testes}. Utilizando a ferramenta StrykerJS para análise de teste de mutação, foi possível identificar fraquezas em uma suíte de testes que, apesar de apresentar alta cobertura de código, não garantia a detecção efetiva de bugs.

O teste de mutação funciona introduzindo pequenas alterações (mutações) no código fonte e verificando se os testes são capazes de detectá-las. Um mutante que ``sobrevive'' indica uma fraqueza na suíte de testes, pois uma alteração no código passou despercebida.

\subsection{Objetivos}

Os principais objetivos deste trabalho foram:

\begin{itemize}
    \item Configurar e executar análise de teste de mutação em um projeto JavaScript
    \item Interpretar relatórios do StrykerJS e identificar mutantes sobreviventes
    \item Analisar criticamente as fraquezas da suíte de testes
    \item Escrever testes eficazes focados em eliminar mutantes específicos
    \item Demonstrar melhoria mensurável através do aumento da pontuação de mutação
    \item Compreender a diferença entre cobertura de código e qualidade de testes
\end{itemize}

\section{Análise Inicial}

\subsection{Cobertura de Código Inicial}

A primeira etapa consistiu em executar a suíte de testes existente e gerar o relatório de cobertura de código utilizando Jest. Os resultados iniciais foram:

\begin{table}[H]
\centering
\caption{Métricas de Cobertura de Código Inicial}
\begin{tabular}{lc}
\toprule
\textbf{Métrica} & \textbf{Percentual} \\
\midrule
Statements (Declarações) & 85,41\% \\
Branches (Ramificações) & 58,82\% \\
Functions (Funções) & \textbf{100\%} \\
Lines (Linhas) & 98,64\% \\
\midrule
\textbf{Número de Testes} & \textbf{50} \\
\bottomrule
\end{tabular}
\label{tab:cobertura_inicial}
\end{table}

À primeira vista, estes números parecem excelentes: 100\% de cobertura de funções e 98,64\% de cobertura de linhas. No entanto, como será demonstrado, alta cobertura não garante testes eficazes.

\subsection{Pontuação de Mutação Inicial}

Após executar o StrykerJS pela primeira vez com o comando \texttt{npx stryker run}, os resultados revelaram uma realidade diferente:

\begin{table}[H]
\centering
\caption{Resultados da Primeira Análise de Mutação}
\begin{tabular}{lc}
\toprule
\textbf{Métrica} & \textbf{Valor} \\
\midrule
Mutation Score & \textbf{73,71\%} \\
Mutantes Criados & 213 \\
Mutantes Mortos (Killed) & 154 \\
Mutantes Sobreviventes (Survived) & \textbf{56} \\
Timeouts & 3 \\
\bottomrule
\end{tabular}
\label{tab:mutacao_inicial}
\end{table}

\subsection{Discrepância entre Cobertura e Eficácia}

A comparação entre as métricas de cobertura e a pontuação de mutação revela um problema crítico:

\begin{itemize}
    \item \textbf{Cobertura de Linhas:} 98,64\% (aparentemente excelente)
    \item \textbf{Mutation Score:} 73,71\% (preocupante)
    \item \textbf{Diferença:} 24,93 pontos percentuais
\end{itemize}

\textbf{Por que isso acontece?}

A cobertura de código mede apenas se o código foi \textit{executado} durante os testes, mas não verifica se o comportamento foi \textit{corretamente validado}. Um teste pode executar uma função inteira sem fazer asserções adequadas sobre os valores de retorno ou comportamentos esperados.

Por exemplo, o teste original da função \texttt{isMaiorQue()}:

\begin{lstlisting}[language=JavaScript, caption=Teste original (fraco)]
test('deve verificar se um numero e maior que outro', () => {
    expect(isMaiorQue(10, 5)).toBe(true);
});
\end{lstlisting}

Este teste executa a função (cobertura = 100\%), mas não testa o caso crítico onde \texttt{a === b}. Quando o StrykerJS muta \texttt{a > b} para \texttt{a >= b}, o teste continua passando, pois \texttt{10 >= 5} também retorna \texttt{true}.

\section{Análise de Mutantes Críticos}

Durante a análise do relatório HTML gerado pelo StrykerJS (\texttt{reports/mutation/mutation.html}), foram identificados diversos mutantes sobreviventes. Três casos foram selecionados para análise detalhada por representarem categorias importantes de falhas em testes.

\subsection{Mutante Crítico \#1: Comparadores de Limites}

\subsubsection{Localização e Descrição}

\textbf{Arquivo:} \texttt{src/operacoes.js} \\
\textbf{Linhas:} 104-106 \\
\textbf{Funções afetadas:} \texttt{isMaiorQue()}, \texttt{isMenorQue()}, \texttt{isEqual()}

O código original implementa funções simples de comparação:

\begin{lstlisting}[language=JavaScript, caption=Código original das funções de comparação]
function isMaiorQue(a, b) { return a > b; }
function isMenorQue(a, b) { return a < b; }
function isEqual(a, b) { return a === b; }
\end{lstlisting}

\subsubsection{Mutações que Sobreviveram}

O StrykerJS gerou as seguintes mutações que \textbf{não foram detectadas} pelos testes:

\begin{lstlisting}[language=JavaScript, caption=Mutantes sobreviventes - Comparadores]
// Mutante 1: Operador > virou >=
function isMaiorQue(a, b) { return a >= b; }

// Mutante 2: Operador < virou <=
function isMenorQue(a, b) { return a <= b; }

// Mutante 3: Condicional virou constante true
function isMaiorQue(a, b) { return true; }
function isMenorQue(a, b) { return true; }
function isEqual(a, b) { return true; }
\end{lstlisting}

\subsubsection{Por que os Testes Originais Falharam?}

Os testes originais apenas verificavam casos onde \texttt{a != b}:

\begin{lstlisting}[language=JavaScript]
test('44. deve verificar se um numero e maior que outro', () => {
    expect(isMaiorQue(10, 5)).toBe(true);
});
test('45. deve verificar se um numero e menor que outro', () => {
    expect(isMenorQue(5, 10)).toBe(true);
});
test('46. deve verificar se dois numeros sao iguais', () => {
    expect(isEqual(7, 7)).toBe(true);
});
\end{lstlisting}

\textbf{Problema identificado:}

\begin{itemize}
    \item Não testava o caso \texttt{a === b} para \texttt{isMaiorQue()} e \texttt{isMenorQue()}
    \item Para \texttt{isMaiorQue(10, 5)}, tanto \texttt{>} quanto \texttt{>=} retornam \texttt{true}
    \item Não testava valores onde a comparação deveria retornar \texttt{false}
    \item Não testava \texttt{isEqual()} com valores diferentes
\end{itemize}

Este é um exemplo clássico de falha em testar \textbf{boundary conditions} (condições de fronteira).

\subsection{Mutante Crítico \#2: Função isPrimo}

\subsubsection{Localização e Descrição}

\textbf{Arquivo:} \texttt{src/operacoes.js} \\
\textbf{Linhas:} 73-78 \\
\textbf{Função afetada:} \texttt{isPrimo()}

Código original:

\begin{lstlisting}[language=JavaScript, caption=Implementação da função isPrimo]
function isPrimo(n) {
  if (n <= 1) return false;
  for (let i = 2; i < n; i++) {
    if (n % i === 0) return false;
  }
  return true;
}
\end{lstlisting}

\subsubsection{Mutações que Sobreviveram}

Total de 8 mutantes sobreviventes nesta função, incluindo:

\begin{lstlisting}[language=JavaScript, caption=Exemplos de mutantes sobreviventes]
// Mutante 1: <= virou <
if (n < 1) return false;

// Mutante 2: false virou true
if (n <= 1) return true;

// Mutante 3: < virou >=
for (let i = 2; i >= n; i++)

// Mutante 4: % virou *
if (n * i === 0) return false;

// Mutante 5: Bloco do loop removido
for (let i = 2; i < n; i++) {}
\end{lstlisting}

\subsubsection{Por que os Testes Originais Falharam?}

O teste original verificava apenas um caso:

\begin{lstlisting}[language=JavaScript]
test('33. deve verificar que um numero e primo', () => {
    expect(isPrimo(7)).toBe(true);
});
\end{lstlisting}

\textbf{Casos NÃO testados:}

\begin{itemize}
    \item Números menores ou iguais a 1 (0, 1, -5)
    \item O número 2 (menor número primo)
    \item Números pares maiores que 2 (4, 6, 8)
    \item Números compostos ímpares (9, 15, 21)
    \item Validação de que números não-primos retornam \texttt{false}
\end{itemize}

Testar apenas um caminho ``feliz'' (7 é primo) deixa diversos mutantes vivos, pois não exercita adequadamente as condições de guarda e o loop de verificação.

\subsection{Mutante Crítico \#3: Conversão de Temperatura}

\subsubsection{Localização e Descrição}

\textbf{Arquivo:} \texttt{src/operacoes.js} \\
\textbf{Linhas:} 93-94 \\
\textbf{Funções afetadas:} \texttt{celsiusParaFahrenheit()}, \texttt{fahrenheitParaCelsius()}

Código original:

\begin{lstlisting}[language=JavaScript, caption=Funções de conversão de temperatura]
function celsiusParaFahrenheit(celsius) {
    return (celsius * 9/5) + 32;
}

function fahrenheitParaCelsius(fahrenheit) {
    return (fahrenheit - 32) * 5/9;
}
\end{lstlisting}

\subsubsection{Mutações que Sobreviveram}

\begin{lstlisting}[language=JavaScript, caption=Mutantes nas fórmulas matemáticas]
// Mutante 1: * virou /
return (celsius / 9/5) + 32;

// Mutante 2: /5 virou *5
return (celsius * 9 * 5) + 32;

// Mutante 3: * virou /
return (fahrenheit - 32) / 5/9;

// Mutante 4: /9 virou *9
return (fahrenheit - 32) * 5 * 9;
\end{lstlisting}

\subsubsection{Por que os Testes Originais Falharam?}

Os testes originais verificavam apenas um ponto específico:

\begin{lstlisting}[language=JavaScript]
test('38. deve converter Celsius para Fahrenheit', () => {
    expect(celsiusParaFahrenheit(0)).toBe(32);
});

test('39. deve converter Fahrenheit para Celsius', () => {
    expect(fahrenheitParaCelsius(32)).toBe(0);
});
\end{lstlisting}

\textbf{Problema crítico:}

Quando \texttt{celsius = 0}, a parte \texttt{(celsius * 9/5)} resulta em 0, independente de a operação estar correta ou não. Assim, tanto \texttt{(0 * 9/5)} quanto \texttt{(0 / 9/5)} ou \texttt{(0 * 9 * 5)} resultam em 0, e a função retorna 32 em todos os casos.

\textbf{Lição aprendida:} Testar apenas valores que anulam parte da lógica (como 0 em multiplicações) não valida adequadamente a correção da fórmula matemática.

\section{Soluções Implementadas}

\subsection{Solução para Comparadores de Limites}

Para eliminar os mutantes das funções de comparação, foram adicionados testes que cobrem todos os casos possíveis:

\begin{lstlisting}[language=JavaScript, caption=Testes aprimorados para comparadores]
// Testes para isMaiorQue
test('44. deve verificar se um numero e maior que outro', () => {
    expect(isMaiorQue(10, 5)).toBe(true);
});
test('44b. deve retornar false quando numeros sao iguais', () => {
    expect(isMaiorQue(5, 5)).toBe(false);
});
test('44c. deve retornar false quando primeiro numero e menor', () => {
    expect(isMaiorQue(3, 8)).toBe(false);
});

// Testes para isMenorQue
test('45. deve verificar se um numero e menor que outro', () => {
    expect(isMenorQue(5, 10)).toBe(true);
});
test('45b. deve retornar false quando numeros sao iguais', () => {
    expect(isMenorQue(5, 5)).toBe(false);
});
test('45c. deve retornar false quando primeiro numero e maior', () => {
    expect(isMenorQue(10, 3)).toBe(false);
});

// Testes para isEqual
test('46. deve verificar se dois numeros sao iguais', () => {
    expect(isEqual(7, 7)).toBe(true);
});
test('46b. deve retornar false quando numeros sao diferentes', () => {
    expect(isEqual(7, 8)).toBe(false);
});
\end{lstlisting}

\textbf{Por que esses testes são eficazes?}

\begin{itemize}
    \item \textbf{Testam boundary conditions:} O caso \texttt{a === b} é crítico para distinguir \texttt{>} de \texttt{>=}
    \item \textbf{Testam ambos os resultados:} Verificam tanto \texttt{true} quanto \texttt{false}
    \item \textbf{Cobrem todas as combinações:} a > b, a < b, a === b
    \item \textbf{Impedem substituições:} \texttt{a > b} não pode ser substituído por \texttt{a >= b} sem falhar
\end{itemize}

\textbf{Resultado:} 6 mutantes eliminados nesta categoria.

\subsection{Solução para isPrimo}

A estratégia foi testar sistematicamente todos os casos limites e caminhos possíveis:

\begin{lstlisting}[language=JavaScript, caption=Suíte completa de testes para isPrimo]
test('33. deve verificar que um numero e primo', () => {
    expect(isPrimo(7)).toBe(true);
});

test('33b. deve retornar false para numeros menores ou iguais a 1', () => {
    expect(isPrimo(0)).toBe(false);
    expect(isPrimo(1)).toBe(false);
    expect(isPrimo(-5)).toBe(false);
});

test('33c. deve retornar true para o numero 2 (menor primo)', () => {
    expect(isPrimo(2)).toBe(true);
});

test('33d. deve retornar false para numeros pares maiores que 2', () => {
    expect(isPrimo(4)).toBe(false);
    expect(isPrimo(6)).toBe(false);
    expect(isPrimo(8)).toBe(false);
});

test('33e. deve retornar false para numeros compostos impares', () => {
    expect(isPrimo(9)).toBe(false);
    expect(isPrimo(15)).toBe(false);
});
\end{lstlisting}

\textbf{Cobertura de casos:}

\begin{table}[H]
\centering
\caption{Casos de Teste para isPrimo}
\begin{tabular}{ll}
\toprule
\textbf{Caso} & \textbf{Justificativa} \\
\midrule
n $\leq$ 1 & Testa condição de guarda inicial \\
n = 2 & Menor número primo, caso especial \\
n par > 2 & Devem ser detectados rapidamente \\
n ímpar composto & Exercita o loop completo \\
n primo & Valida resultado positivo \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Por que esses testes são eficazes?}

\begin{itemize}
    \item Testam a condição de guarda (\texttt{n <= 1})
    \item Validam que o operador \texttt{<=} não pode ser \texttt{<}
    \item Exercitam o loop com diferentes valores
    \item Garantem que \texttt{\%} não pode ser substituído por \texttt{*}
    \item Verificam que o loop não pode ser removido
\end{itemize}

\textbf{Resultado:} 8 mutantes eliminados.

\subsection{Solução para Conversão de Temperatura}

A chave foi testar múltiplos valores que validam toda a fórmula matemática:

\begin{lstlisting}[language=JavaScript, caption=Testes robustos para conversão de temperatura]
// Celsius para Fahrenheit
test('38. deve converter Celsius para Fahrenheit', () => {
    expect(celsiusParaFahrenheit(0)).toBe(32);
});
test('38b. deve converter 100C para 212F', () => {
    expect(celsiusParaFahrenheit(100)).toBe(212);
});
test('38c. deve converter -40C para -40F', () => {
    expect(celsiusParaFahrenheit(-40)).toBe(-40);
});
test('38d. deve converter 37C para 98.6F (temperatura corporal)', () => {
    expect(celsiusParaFahrenheit(37)).toBeCloseTo(98.6, 1);
});

// Fahrenheit para Celsius
test('39. deve converter Fahrenheit para Celsius', () => {
    expect(fahrenheitParaCelsius(32)).toBe(0);
});
test('39b. deve converter 212F para 100C', () => {
    expect(fahrenheitParaCelsius(212)).toBe(100);
});
test('39c. deve converter -40F para -40C', () => {
    expect(fahrenheitParaCelsius(-40)).toBe(-40);
});
test('39d. deve converter 98.6F para 37C (temperatura corporal)', () => {
    expect(fahrenheitParaCelsius(98.6)).toBeCloseTo(37, 1);
});
\end{lstlisting}

\textbf{Estratégia de valores escolhidos:}

\begin{itemize}
    \item \textbf{0°C / 32°F:} Ponto de congelamento da água
    \item \textbf{100°C / 212°F:} Ponto de ebulição da água
    \item \textbf{-40°C / -40°F:} Ponto onde as escalas coincidem
    \item \textbf{37°C / 98.6°F:} Temperatura corporal (valor não-inteiro)
\end{itemize}

\textbf{Por que esses testes são eficazes?}

\begin{itemize}
    \item Valores não-zero garantem que todas as operações matemáticas são validadas
    \item O ponto -40 detecta erros de sinal
    \item Valores conhecidos permitem verificação imediata
    \item Impossível que mutações matemáticas (\texttt{* → /}, \texttt{/ → *}) passem despercebidas
\end{itemize}

\textbf{Resultado:} 4 mutantes eliminados.

\subsection{Outras Melhorias Implementadas}

Além dos três casos críticos analisados, diversas outras melhorias foram implementadas:

\subsubsection{Validação de Mensagens de Erro Específicas}

\begin{lstlisting}[language=JavaScript]
// Antes (fraco)
expect(() => divisao(5, 0)).toThrow();

// Depois (forte)
expect(() => divisao(5, 0)).toThrow('Divisao por zero nao e permitida.');
\end{lstlisting}

Isso elimina mutantes que alteram strings literais nas mensagens de erro.

\subsubsection{Testes para Arrays Vazios}

\begin{lstlisting}[language=JavaScript]
test('9b. deve retornar 0 para array vazio', () => {
    expect(mediaArray([])).toBe(0);
});

test('11b. deve lancar erro para array vazio (maximoArray)', () => {
    expect(() => maximoArray([])).toThrow('Array vazio');
});
\end{lstlisting}

\subsubsection{Testes para Função Clamp (Limites)}

\begin{lstlisting}[language=JavaScript]
test('36b. deve retornar minimo quando valor e menor que min', () => {
    expect(clamp(-5, 0, 10)).toBe(0);
});
test('36c. deve retornar maximo quando valor e maior que max', () => {
    expect(clamp(15, 0, 10)).toBe(10);
});
test('36d. deve retornar min quando valor e igual a min', () => {
    expect(clamp(0, 0, 10)).toBe(0);
});
test('36e. deve retornar max quando valor e igual a max', () => {
    expect(clamp(10, 0, 10)).toBe(10);
});
\end{lstlisting}

\subsubsection{Testes para Mediana com Ordenação}

\begin{lstlisting}[language=JavaScript]
test('47c. deve calcular a mediana de array desordenado', () => {
    expect(medianaArray([5, 1, 3, 2, 4])).toBe(3);
});
test('47g. deve calcular mediana com valores negativos', () => {
    expect(medianaArray([-5, -1, -3])).toBe(-3);
    expect(medianaArray([-10, -5, 0, 5])).toBe(-2.5);
});
\end{lstlisting}

\section{Resultados Finais}

\subsection{Evolução da Pontuação de Mutação}

A tabela abaixo apresenta a evolução completa dos resultados ao longo do processo de melhoria:

\begin{table}[H]
\centering
\caption{Evolução Completa dos Resultados}
\begin{tabular}{lcccc}
\toprule
\textbf{Métrica} & \textbf{Inicial} & \textbf{1ª Melhoria} & \textbf{Final} & \textbf{Variação} \\
\midrule
Mutation Score & 73,71\% & 94,84\% & \textbf{96,71\%} & \textcolor{green}{+23,00 pp} \\
Mutantes Mortos & 154 & 199 & \textbf{203} & +49 \\
Mutantes Sobreviventes & 56 & 11 & \textbf{7} & -49 \\
Timeouts & 3 & 3 & 3 & 0 \\
Número de Testes & 50 & 92 & \textbf{99} & +49 \\
\bottomrule
\end{tabular}
\label{tab:evolucao}
\end{table}

\subsection{Análise Comparativa}

\begin{figure}[H]
\centering
\begin{tabular}{cc}
\textbf{Antes} & \textbf{Depois} \\
\hline
\begin{minipage}{0.45\textwidth}
\begin{itemize}
    \item 50 testes
    \item 73,71\% mutation score
    \item 56 mutantes vivos
    \item Testes superficiais
    \item Apenas caminhos felizes
    \item Sem boundary conditions
\end{itemize}
\end{minipage}
&
\begin{minipage}{0.45\textwidth}
\begin{itemize}
    \item 99 testes (+98\%)
    \item 96,71\% mutation score
    \item 7 mutantes vivos (-87,5\%)
    \item Testes robustos
    \item Casos positivos e negativos
    \item Boundary conditions testadas
\end{itemize}
\end{minipage}
\end{tabular}
\caption{Comparação: Antes vs Depois}
\end{figure}

\subsection{Métricas de Cobertura Final}

Interessantemente, as métricas tradicionais de cobertura de código permaneceram praticamente inalteradas:

\begin{table}[H]
\centering
\caption{Cobertura de Código: Inicial vs Final}
\begin{tabular}{lcc}
\toprule
\textbf{Métrica} & \textbf{Inicial} & \textbf{Final} \\
\midrule
Statements & 85,41\% & 85,41\% \\
Branches & 58,82\% & 58,82\% \\
Functions & 100\% & 100\% \\
Lines & 98,64\% & 98,64\% \\
\midrule
\textbf{Mutation Score} & \textbf{73,71\%} & \textbf{96,71\%} \\
\bottomrule
\end{tabular}
\end{table}

Isso demonstra de forma conclusiva que \textbf{cobertura de código não mede qualidade de testes}. A cobertura permaneceu a mesma, mas a eficácia dos testes aumentou dramaticamente.

\subsection{Impacto Prático da Melhoria}

A diferença entre 73,71\% e 96,71\% de mutation score representa:

\begin{itemize}
    \item \textbf{Antes:} Apenas 3 em cada 4 bugs introduzidos seriam detectados
    \item \textbf{Depois:} Praticamente todos os bugs (97 em cada 100) seriam detectados
    \item \textbf{Redução de risco:} 87,5\% menos mutantes escapando
\end{itemize}

Em um cenário real de produção, isso significa:

\begin{itemize}
    \item Menos bugs em produção
    \item Maior confiança ao refatorar código
    \item Detecção precoce de regressões
    \item Redução de custos com correção de bugs
\end{itemize}

\subsection{Mutantes Remanescentes}

Os 7 mutantes que ainda sobrevivem são casos extremamente específicos:

\begin{enumerate}
    \item \textbf{Fatorial - Condições booleanas internas (4 mutantes):}
    \begin{itemize}
        \item Mutações em subexpressões do \texttt{if (n === 0 || n === 1)}
        \item Casos onde \texttt{||} é substituído por \texttt{\&\&}
        \item Difíceis de eliminar sem refatorar a lógica
    \end{itemize}
    
    \item \textbf{produtoArray - Array vazio (1 mutante):}
    \begin{itemize}
        \item Condicional \texttt{if (false)} em vez de \texttt{if (numeros.length === 0)}
    \end{itemize}
    
    \item \textbf{Clamp - Operadores de comparação (2 mutantes):}
    \begin{itemize}
        \item \texttt{<} vs \texttt{<=} e \texttt{>} vs \texttt{>=} em casos limítrofes
    \end{itemize}
\end{enumerate}

Estes mutantes representam menos de \textbf{3,3\%} do total e são aceitáveis considerando que:

\begin{itemize}
    \item São casos extremos de otimização
    \item Não representam bugs reais
    \item Exigiriam refatoração do código fonte para eliminar
    \item A pontuação de 96,71\% já é considerada excelente
\end{itemize}

\section{Conclusão}

\subsection{Principais Aprendizados}

Este trabalho demonstrou de forma prática e mensurável conceitos fundamentais sobre qualidade de software:

\subsubsection{1. Cobertura de Código ≠ Qualidade de Testes}

O projeto iniciou com 98,64\% de cobertura de linhas e 100\% de cobertura de funções, métricas que indicariam uma suíte de testes excelente. No entanto, a pontuação de mutação de apenas 73,71\% revelou que aproximadamente 1 em cada 4 mutantes (bugs potenciais) não seria detectado.

A cobertura mede se o código foi \textit{executado}. O teste de mutação mede se o código foi \textit{corretamente testado}.

\subsubsection{2. Teste de Mutação Revela Fraquezas Ocultas}

Os 56 mutantes sobreviventes iniciais apontaram com precisão cirúrgica as fraquezas da suíte de testes:

\begin{itemize}
    \item Falta de testes para boundary conditions (valores limites)
    \item Ausência de casos negativos (quando deve retornar false)
    \item Testes apenas de ``caminhos felizes''
    \item Validações superficiais de exceções
    \item Fórmulas matemáticas testadas apenas com valores nulos
\end{itemize}

\subsubsection{3. Testes Eficazes Requerem Pensamento Crítico}

Não é suficiente escrever um teste que ``passa''. É necessário questionar:

\begin{itemize}
    \item Este teste detectaria se o operador \texttt{>} fosse trocado por \texttt{>=}?
    \item Testei o caso onde os valores são iguais?
    \item Testei valores que anulam partes da lógica (como 0 em multiplicações)?
    \item Testei tanto resultados positivos quanto negativos?
    \item As asserções são específicas o suficiente?
\end{itemize}

\subsubsection{4. Boundary Conditions São Críticos}

A maioria dos mutantes sobreviventes estava relacionada a condições de fronteira:

\begin{itemize}
    \item \texttt{>} vs \texttt{>=}
    \item \texttt{<} vs \texttt{<=}
    \item \texttt{n === 0} vs \texttt{n === 1}
    \item Arrays vazios vs arrays com um elemento
\end{itemize}

Testar apenas valores ``no meio'' deixa estas fronteiras vulneráveis.

\subsection{Importância do Teste de Mutação na Engenharia de Software}

O teste de mutação não é apenas uma ferramenta acadêmica, mas uma técnica essencial para projetos críticos:

\subsubsection{Vantagens Práticas}

\begin{enumerate}
    \item \textbf{Detecção de Gaps:} Identifica precisamente onde a suíte de testes é fraca
    \item \textbf{Melhoria Guiada:} Cada mutante sobrevivente aponta um teste específico a adicionar
    \item \textbf{Confiança em Refatoração:} Alta pontuação de mutação permite refatorar com segurança
    \item \textbf{Prevenção de Regressões:} Bugs sutis são detectados antes de chegarem à produção
    \item \textbf{Cultura de Qualidade:} Eleva o padrão de escrita de testes da equipe
\end{enumerate}

\subsubsection{Quando Usar}

Teste de mutação é especialmente valioso em:

\begin{itemize}
    \item Sistemas financeiros (onde bugs podem custar dinheiro)
    \item Aplicações médicas (onde bugs podem custar vidas)
    \item Infraestrutura crítica (sistemas de controle, segurança)
    \item Bibliotecas e frameworks (usados por muitos desenvolvedores)
    \item Código legado sendo refatorado
\end{itemize}

\subsection{Limitações e Considerações}

É importante reconhecer que o teste de mutação tem custos:

\begin{itemize}
    \item \textbf{Tempo de execução:} Cada mutante requer execução completa da suíte
    \item \textbf{Recursos computacionais:} Pode ser pesado para projetos grandes
    \item \textbf{Mutantes equivalentes:} Alguns mutantes não mudam o comportamento real
    \item \textbf{Não substitui revisão de código:} É uma ferramenta complementar
\end{itemize}

No entanto, para código crítico, estes custos são justificáveis.

\subsection{Reflexão Final}

Este trabalho transformou a compreensão sobre qualidade de testes. Antes, acreditava-se que alta cobertura era sinônimo de bons testes. Após a experiência prática com teste de mutação, ficou claro que:

\begin{quote}
\textit{``Cobertura de código mede se o código foi executado. Teste de mutação mede se o código foi corretamente testado. A diferença é fundamental.''}
\end{quote}

A melhoria de 73,71\% para 96,71\% na pontuação de mutação representa não apenas números, mas uma mudança de mentalidade: de ``testes que passam'' para ``testes que realmente protegem o código''.

Para projetos onde qualidade é crítica, o teste de mutação não é opcional --- é essencial.

\subsection{Próximos Passos}

Com base nesta experiência, recomenda-se:

\begin{enumerate}
    \item Integrar teste de mutação no CI/CD do projeto
    \item Estabelecer threshold mínimo de mutation score (ex: 95\%)
    \item Executar mutação apenas em código crítico (otimização de tempo)
    \item Treinar a equipe em técnicas de boundary testing
    \item Considerar ferramentas como Stryker para outros projetos
\end{enumerate}

\section{Referências}

\begin{enumerate}
    \item StrykerJS Official Documentation. Disponível em: \url{https://stryker-mutator.io/docs/}
    \item Mutation Testing Elements - Supported Mutators. Disponível em: \url{https://stryker-mutator.io/docs/mutation-testing-elements/supported-mutators/}
    \item Repositório do Projeto Base: \url{https://github.com/CleitonSilvaT/operacoes-mutante}
    \item Repositório da Solução: \url{https://github.com/LuizNeryy/operacoes-mutante}
    \item Jest Testing Framework. Disponível em: \url{https://jestjs.io/}
    \item Jia, Y., \& Harman, M. (2011). An analysis and survey of the development of mutation testing. IEEE transactions on software engineering, 37(5), 649-678.
\end{enumerate}

\end{document}
